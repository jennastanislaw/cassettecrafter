"""
Test suite for utility functions related to oligonucleotide design and sequence manipulation.

This script contains unit tests for various functions defined in the `split_sites_utils` module,
which are used for tasks such as identifying consecutive indices, adjusting oligo lengths,
calculating oligo lengths, and handling overhangs and recognition sites.

Tests cover different edge cases and ensure correct functionality for each utility,
including scenarios where the inputs are empty, invalid, or edge case values.

Functions being tested:
- `find_starts_of_consecutive_indices`: Identifies the starting indices of consecutive sequences in a list.
- `adjust_oligo_lengths`: Adjusts oligonucleotide lengths based on recognition site length, spacer length, and overhang length.
- `calculate_oligo_lengths`: Calculates oligonucleotide lengths based on split indices and overhang length.
- `is_valid_overhang`: Validates whether a given overhang length is acceptable.
- `hamming_distance`: Calculates the Hamming distance between two sequences.
- `find_constant_indices`: Finds indices where a specific condition (e.g., constant sequence values) is met.

Each test method contains descriptive assertions to ensure correctness for the associated function under varying conditions.
"""

import pytest
import sys
import os
import pandas as pd

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../src')))
from split_sites_utils import (
    find_starts_of_consecutive_indices,
    adjust_oligo_lengths,
    calculate_oligo_lengths,
    generate_cassettes,
    is_valid_overhang,
    hamming_distance,
    find_constant_indices
)

class Enzyme:
    """
    A class representing a restriction enzyme with its recognition sites and associated properties.

    Attributes:
        name (str): The name of the enzyme.
        fwd_recognition_site (str): The forward recognition sequence for the enzyme.
        rev_recognition_site (str): The reverse recognition sequence for the enzyme.
        spacer_length (int): The length of the spacer sequence used by the enzyme.
        OH_length (int): The length of the overhang (OH) generated by the enzyme after cutting.

    Methods:
        __repr__(): Returns a string representation of the Enzyme object, displaying its properties.
    """

    def __init__(self, name, fwd_recognition_site, rev_recognition_site, spacer_length, OH_length):
        """
        Initializes an Enzyme object with the given attributes.

        Args:
            name (str): The name of the enzyme.
            fwd_recognition_site (str): The forward recognition sequence for the enzyme.
            rev_recognition_site (str): The reverse recognition sequence for the enzyme.
            spacer_length (int): The length of the spacer sequence used by the enzyme.
            OH_length (int): The length of the overhang (OH) generated by the enzyme after cutting.
        """
        self.name = name  # Name of the enzyme
        self.fwd_recognition_site = fwd_recognition_site  # Forward recognition site sequence
        self.rev_recognition_site = rev_recognition_site  # Reverse recognition site sequence
        self.spacer_length = spacer_length  # Length of the spacer sequence
        self.OH_length = OH_length  # Length of the overhang (OH) generated after cutting

    def __repr__(self):
        """
        Returns a string representation of the Enzyme object, displaying its attributes.

        This method is useful for debugging and printing the enzyme object in a readable format.

        Returns:
            str: A formatted string representation of the Enzyme object.
        """
        return (f"Enzyme(name={self.name}, "
                f"fwd_recognition_site={self.fwd_recognition_site}, "
                f"rev_recognition_site={self.rev_recognition_site}, "
                f"spacer_length={self.spacer_length}, "
                f"OH_length={self.OH_length})")


class TestFindStartsOfConsecutiveIndices:
    """Test suite for the `find_starts_of_consecutive_indices` function."""

    def test_empty_conserved_indices(self):
        """Test with an empty conserved indices list."""
        conserved_indices = []
        consecutive_count = 4
        assert find_starts_of_consecutive_indices(conserved_indices, consecutive_count) == []

    def test_no_consecutive_indices(self):
        """Test with no consecutive indices."""
        conserved_indices = [1, 3, 5, 7]
        consecutive_count = 3
        assert find_starts_of_consecutive_indices(conserved_indices, consecutive_count) == []

    def test_single_consecutive_set(self):
        """Test with one set of consecutive indices."""
        conserved_indices = [1, 2, 3, 4, 6, 7]
        consecutive_count = 4
        assert find_starts_of_consecutive_indices(conserved_indices, consecutive_count) == [0]

    def test_multiple_consecutive_sets(self):
        """Test with multiple sets of consecutive indices."""
        conserved_indices = [1, 2, 3, 4, 5, 7, 8, 9, 10]
        consecutive_count = 4
        assert find_starts_of_consecutive_indices(conserved_indices, consecutive_count) == [0, 1, 5]

    def test_exact_length_match(self):
        """Test when the list length matches the consecutive count."""
        conserved_indices = [1, 2, 3, 4]
        consecutive_count = 4
        assert find_starts_of_consecutive_indices(conserved_indices, consecutive_count) == [0]

    def test_consecutive_count_greater_than_list_length(self):
        """Test when the consecutive count is greater than the list length."""
        conserved_indices = [1, 2, 3]
        consecutive_count = 4
        assert find_starts_of_consecutive_indices(conserved_indices, consecutive_count) == []

    def test_mixed_consecutive_and_non_consecutive(self):
        """Test with a mix of consecutive and non-consecutive indices."""
        conserved_indices = [1, 2, 3, 5, 6, 7, 9, 10, 11]
        consecutive_count = 3
        assert find_starts_of_consecutive_indices(conserved_indices, consecutive_count) == [0, 3, 6]


class TestAdjustOligoLengths:
    """Test suite for the `adjust_oligo_lengths` function."""

    def test_basic_adjustment(self):
        """Test a standard case with valid inputs."""
        min_oligo_len = 50
        max_oligo_len = 100
        recognition_site_len = 4
        spacer_bps = 3
        OH_len = 2
        assert adjust_oligo_lengths(min_oligo_len, max_oligo_len, recognition_site_len, spacer_bps, OH_len) == (
            32, 82)

    def test_min_length_less_than_adjustment(self):
        """Test when the min_oligo_len becomes less than 1 after adjustment."""
        min_oligo_len = 10
        max_oligo_len = 100
        recognition_site_len = 10
        spacer_bps = 5
        OH_len = 5
        assert adjust_oligo_lengths(min_oligo_len, max_oligo_len, recognition_site_len, spacer_bps, OH_len) == (
            1, 60)

    def test_zero_spacer_and_OH(self):
        """Test when spacer_bps and OH_len are zero."""
        min_oligo_len = 50
        max_oligo_len = 100
        recognition_site_len = 6
        spacer_bps = 0
        OH_len = 0
        assert adjust_oligo_lengths(min_oligo_len, max_oligo_len, recognition_site_len, spacer_bps, OH_len) == (
            38, 88)

    def test_zero_recognition_site_len(self):
        """Test when recognition_site_len is zero."""
        min_oligo_len = 50
        max_oligo_len = 100
        recognition_site_len = 0
        spacer_bps = 2
        OH_len = 3
        assert adjust_oligo_lengths(min_oligo_len, max_oligo_len, recognition_site_len, spacer_bps, OH_len) == (
            40, 90)

    def test_min_equals_max(self):
        """Test when min_oligo_len equals max_oligo_len."""
        min_oligo_len = 100
        max_oligo_len = 100
        recognition_site_len = 5
        spacer_bps = 2
        OH_len = 3
        assert adjust_oligo_lengths(min_oligo_len, max_oligo_len, recognition_site_len, spacer_bps, OH_len) == (
            80, 80)

    def test_min_and_max_below_adjustment(self):
        """Test when both min_oligo_len and max_oligo_len are less than the adjustment."""
        min_oligo_len = 20
        max_oligo_len = 30
        recognition_site_len = 10
        spacer_bps = 5
        OH_len = 5
        try:
            adjust_oligo_lengths(min_oligo_len, max_oligo_len, recognition_site_len, spacer_bps, OH_len)
        except ValueError as e:
            assert str(e) == (
                "The max oligo length (30) is incompatible with the selected enzyme. "
                "It must be at least 40 to accommodate the enzyme properties "
                "(recognition site: 10, spacer: 5, overhang: 5)."
            )
        else:
            assert False, "Expected ValueError to be raised for incompatible max oligo length."

    def test_exactly_equal_to_adjustment(self):
        """Test when max_oligo_len is exactly equal to the required adjustment."""
        min_oligo_len = 40
        max_oligo_len = 40
        recognition_site_len = 10
        spacer_bps = 5
        OH_len = 5
        assert adjust_oligo_lengths(min_oligo_len, max_oligo_len, recognition_site_len, spacer_bps, OH_len) == (
            1, 1)

    def test_max_oligo_less_than_adjustment(self):
        """Test when max_oligo_len is less than the adjustment, raising an error."""
        min_oligo_len = 50
        max_oligo_len = 20
        recognition_site_len = 6
        spacer_bps = 5
        OH_len = 3
        try:
            adjust_oligo_lengths(min_oligo_len, max_oligo_len, recognition_site_len, spacer_bps, OH_len)
        except ValueError as e:
            assert str(e) == (
                "The max oligo length (20) is incompatible with the selected enzyme. "
                "It must be at least 28 to accommodate the enzyme properties "
                "(recognition site: 6, spacer: 5, overhang: 3)."
            )
        else:
            assert False, "Expected ValueError to be raised for incompatible max oligo length."


class TestCalculateOligoLengths:
    """Test suite for the `calculate_oligo_lengths` function."""

    def test_no_split_indices(self):
        """
        Test case where no split indices are provided. The entire reference sequence should
        be considered as a single oligo of length equal to the length of the reference sequence.
        """
        reference = "ATGCATGCATGC"
        split_indices = []
        OH_len = 5
        assert calculate_oligo_lengths(reference, split_indices, OH_len) == [12]

    def test_single_split_index(self):
        """
        Test case where a single split index is provided. The reference sequence should be split
        into two oligos at the specified index.
        """
        reference = "ATGCATGCATGC"
        split_indices = [4]
        OH_len = 5
        assert calculate_oligo_lengths(reference, split_indices, OH_len) == [9, 8]

    def test_multiple_split_indices(self):
        """
        Test case where multiple split indices are provided. The reference sequence should be split
        into multiple oligos at each specified index.
        """
        reference = "ATGCATGCATGC"
        split_indices = [4, 8]
        OH_len = 3
        assert calculate_oligo_lengths(reference, split_indices, OH_len) == [7, 7, 4]

    def test_invalid_split_index_negative(self):
        """
        Test case where a negative split index is provided. This should raise a ValueError because
        negative indices are out of range for the reference sequence.
        """
        reference = "ATGCATGCATGC"
        split_indices = [-1, 4]
        OH_len = 2
        with pytest.raises(ValueError,
                           match="One or more split indices are out of the range of the reference sequence length."):
            calculate_oligo_lengths(reference, split_indices, OH_len)

    def test_invalid_split_index_out_of_range(self):
        """
        Test case where a split index is out of the valid range (greater than the reference sequence length).
        This should raise a ValueError.
        """
        reference = "ATGCATGCATGC"
        split_indices = [4, 13]
        OH_len = 2
        with pytest.raises(ValueError,
                           match="One or more split indices are out of the range of the reference sequence length."):
            calculate_oligo_lengths(reference, split_indices, OH_len)

    def test_split_at_start(self):
        """
        Test case where the split index is at the start of the reference sequence (index 0).
        The reference sequence should be split into two oligos, one starting from the beginning.
        """
        reference = "ATGCATGCATGC"
        split_indices = [0]
        OH_len = 2
        assert calculate_oligo_lengths(reference, split_indices, OH_len) == [2, 12]

    def test_split_at_end(self):
        """
        Test case where the split index is at the end of the reference sequence (last index).
        The reference sequence should be split into two oligos, with one oligo being empty after the split.
        """
        reference = "ATGCATGCATGC"
        split_indices = [12]
        OH_len = 4
        assert calculate_oligo_lengths(reference, split_indices, OH_len) == [16, 0]


class TestAdjustOligoLengths:
    """Test suite for the `adjust_oligo_lengths` function."""

    def test_basic_adjustment(self):
        """Test a standard case with valid inputs."""
        min_oligo_len = 50
        max_oligo_len = 100
        recognition_site_len = 4
        spacer_bps = 3
        OH_len = 2
        assert adjust_oligo_lengths(min_oligo_len, max_oligo_len, recognition_site_len, spacer_bps, OH_len) == (32, 82)

    def test_min_length_less_than_adjustment(self):
        """Test when the min_oligo_len becomes less than 1 after adjustment."""
        min_oligo_len = 10
        max_oligo_len = 100
        recognition_site_len = 10
        spacer_bps = 5
        OH_len = 5
        assert adjust_oligo_lengths(min_oligo_len, max_oligo_len, recognition_site_len, spacer_bps, OH_len) == (1, 60)

    def test_zero_spacer_and_OH(self):
        """Test when spacer_bps and OH_len are zero."""
        min_oligo_len = 50
        max_oligo_len = 100
        recognition_site_len = 6
        spacer_bps = 0
        OH_len = 0
        assert adjust_oligo_lengths(min_oligo_len, max_oligo_len, recognition_site_len, spacer_bps, OH_len) == (38, 88)

    def test_zero_recognition_site_len(self):
        """Test when recognition_site_len is zero."""
        min_oligo_len = 50
        max_oligo_len = 100
        recognition_site_len = 0
        spacer_bps = 2
        OH_len = 3
        assert adjust_oligo_lengths(min_oligo_len, max_oligo_len, recognition_site_len, spacer_bps, OH_len) == (40, 90)

    def test_min_equals_max(self):
        """Test when min_oligo_len equals max_oligo_len."""
        min_oligo_len = 100
        max_oligo_len = 100
        recognition_site_len = 5
        spacer_bps = 2
        OH_len = 3
        assert adjust_oligo_lengths(min_oligo_len, max_oligo_len, recognition_site_len, spacer_bps, OH_len) == (80, 80)

    def test_min_and_max_below_adjustment(self):
        """Test when both min_oligo_len and max_oligo_len are less than the adjustment."""
        min_oligo_len = 20
        max_oligo_len = 30
        recognition_site_len = 10
        spacer_bps = 5
        OH_len = 5
        try:
            adjust_oligo_lengths(min_oligo_len, max_oligo_len, recognition_site_len, spacer_bps, OH_len)
        except ValueError as e:
            assert str(e) == (
                "The max oligo length (30) is incompatible with the selected enzyme. "
                "It must be at least 41 to accommodate the enzyme properties "
                "(recognition site: 10, spacer: 5, overhang: 5)."
            )
        else:
            assert False, "Expected ValueError to be raised for incompatible max oligo length."

    def test_exactly_equal_to_adjustment(self):
        """Test when max_oligo_len is exactly equal to the required adjustment."""
        min_oligo_len = 40
        max_oligo_len = 40
        recognition_site_len = 10
        spacer_bps = 5
        OH_len = 5
        try:
            adjust_oligo_lengths(min_oligo_len, max_oligo_len, recognition_site_len, spacer_bps, OH_len)
        except ValueError as e:
            assert str(e) == (
                "The max oligo length (40) is incompatible with the selected enzyme. "
                "It must be at least 41 to accommodate the enzyme properties "
                "(recognition site: 10, spacer: 5, overhang: 5)."
            )
        else:
            assert False, "Expected ValueError to be raised for incompatible max oligo length."

    def test_max_oligo_len_less_than_adjustment(self):
        """Test when max_oligo_len is less than or equal to the adjustment, raising an error."""
        min_oligo_len = 50
        max_oligo_len = 20
        recognition_site_len = 6
        spacer_bps = 5
        OH_len = 3
        try:
            adjust_oligo_lengths(min_oligo_len, max_oligo_len, recognition_site_len, spacer_bps, OH_len)
        except ValueError as e:
            assert str(e) == (
                "The max oligo length (20) is incompatible with the selected enzyme. "
                "It must be at least 29 to accommodate the enzyme properties "
                "(recognition site: 6, spacer: 5, overhang: 3)."
            )
        else:
            assert False, "Expected ValueError to be raised for incompatible max oligo length."


class TestGenerateCassettes:
    """
    A test suite for the `generate_cassettes` function, testing its behavior with different split sites
    and DNA sequences. The tests ensure that the function correctly generates cassettes from the provided
    DNA sequences based on the enzyme's overhang length and specified split sites.

    Methods:
        enzyme(): A fixture that creates a test enzyme to be used in the test cases.
        test_single_split_site(enzyme): Tests the case where there is a single split site in the DNA sequences.
        test_multiple_split_sites(enzyme): Tests the case where there are multiple split sites in the DNA sequences.
        test_no_split_sites(enzyme): Tests the case where there are no split sites in the DNA sequences.
        test_empty_dataframe(enzyme): Tests the case where the input DNA dataframe is empty.
    """

    @pytest.fixture
    def enzyme(self):
        """
        Creates a test enzyme with predefined recognition sites and overhang length.

        Returns:
            Enzyme: A test Enzyme object with a name, recognition sites, spacer length, and overhang length.
        """
        return Enzyme("TestEnzyme", "GAATTC", "CTTAAG", 0, 3)

    def test_single_split_site(self, enzyme):
        """
        Tests the `generate_cassettes` function when there is a single split site in the DNA sequences.

        The test provides a dataframe with two DNA sequences and a list of split sites, and checks
        whether the function generates the correct cassette sequences based on the specified split site.

        Args:
            enzyme (Enzyme): The enzyme fixture used to provide the enzyme object for this test.

        Asserts:
            The result should match the expected dataframe with the correct cassette sequences.
        """
        DNA_df = pd.DataFrame({
            'rec_sites_removed': ['ATGCATGCATGC', 'GCATGCATGCAT']
        })
        split_sites = [0, 4, 12]

        # Call the generate_cassettes function with the enzyme's OH_length
        result = generate_cassettes(DNA_df, split_sites, enzyme)

        expected = pd.DataFrame({
            'rec_sites_removed': ['ATGCATGCATGC', 'GCATGCATGCAT'],
            'Cassette 1': ['ATGCATG', 'GCATGCA'],
            'Cassette 2': ['ATGCATGC', 'GCATGCAT'],
        })

        pd.testing.assert_frame_equal(result, expected)

    def test_multiple_split_sites(self, enzyme):
        """
        Tests the `generate_cassettes` function when there are multiple split sites in the DNA sequences.

        The test provides a dataframe with two DNA sequences and multiple split sites, and checks
        whether the function correctly generates multiple cassette sequences for each DNA sequence.

        Args:
            enzyme (Enzyme): The enzyme fixture used to provide the enzyme object for this test.

        Asserts:
            The result should match the expected dataframe with the correct cassette sequences for multiple split sites.
        """
        DNA_df = pd.DataFrame({
            'rec_sites_removed': ['ATGCATGCATGC', 'GCATGCATGCAT'],
        })
        split_sites = [0, 2, 5, 12]

        # Call the generate_cassettes function with the enzyme's OH_length
        result = generate_cassettes(DNA_df, split_sites, enzyme)

        expected = pd.DataFrame({
            'rec_sites_removed': ['ATGCATGCATGC', 'GCATGCATGCAT'],
            'Cassette 1': ['ATGCA', 'GCATG'],
            'Cassette 2': ['GCATGC', 'ATGCAT'],
            'Cassette 3': ['TGCATGC', 'CATGCAT'],
        })

        pd.testing.assert_frame_equal(result, expected)

    def test_no_split_sites(self, enzyme):
        """
        Tests the `generate_cassettes` function when there are no split sites in the DNA sequences.

        The test provides a dataframe with two DNA sequences and split sites at the start and end of each sequence.
        It ensures that the function correctly handles cases where no actual splitting occurs.

        Args:
            enzyme (Enzyme): The enzyme fixture used to provide the enzyme object for this test.

        Asserts:
            The result should match the expected dataframe with the original DNA sequences unchanged.
        """
        DNA_df = pd.DataFrame({
            'rec_sites_removed': ['ATGCATGC', 'GCATGCAT']
        })
        split_sites = [0, 8]

        # Call the generate_cassettes function with the enzyme's OH_length
        result = generate_cassettes(DNA_df, split_sites, enzyme)

        expected = pd.DataFrame({
            'rec_sites_removed': ['ATGCATGC', 'GCATGCAT'],
            'Cassette 1': ['ATGCATGC', 'GCATGCAT']
        })

        pd.testing.assert_frame_equal(result, expected)

    def test_empty_dataframe(self, enzyme):
        """
        Tests the `generate_cassettes` function when the input DNA dataframe is empty.

        This test ensures that the function handles cases where there are no DNA sequences provided
        and returns an empty dataframe.

        Args:
            enzyme (Enzyme): The enzyme fixture used to provide the enzyme object for this test.

        Asserts:
            The result should be an empty dataframe with no cassettes.
        """
        DNA_df = pd.DataFrame({
            'rec_sites_removed': []
        })
        split_sites = [0, 4]

        # Call the generate_cassettes function with the enzyme's OH_length
        result = generate_cassettes(DNA_df, split_sites, enzyme)

        expected = pd.DataFrame({
            'rec_sites_removed': [],
            'Cassette 1': []
        })

        pd.testing.assert_frame_equal(result, expected)


class TestIsValidOverhang:
    """
       A test suite for the `is_valid_overhang` function, which validates the quality of a DNA overhang.

       The tests check various scenarios for DNA overhangs, including palindromes, repeated nucleotides,
       extreme GC content, and edge cases. The function should return `True` for valid overhangs and `False`
       for invalid ones, according to the following criteria:
       - Palindromes are invalid.
       - Overhangs with three consecutive repeated nucleotides are invalid.
       - Overhangs with 0% or 100% GC content are invalid.
       - Empty overhangs are considered valid.
       - Overhangs with a single nucleotide or mixed GC content are considered valid.

       Methods:
           test_palindrome(): Tests that palindromes return False.
           test_repeated_nucleotides(): Tests that overhangs with three consecutive repeated nucleotides return False.
           test_extreme_gc_content_0(): Tests that overhangs with 0% GC content return False.
           test_extreme_gc_content_100(): Tests that overhangs with 100% GC content return False.
           test_valid_overhang(): Tests that valid overhangs return True.
           test_edge_case_empty_overhang(): Tests that an empty overhang returns False.
           test_edge_case_single_nucleotide(): Tests that a single nucleotide overhang is valid.
           test_mixed_gc_content(): Tests that overhangs with mixed GC content return True.
       """
    def test_palindrome(self):
        """Test that palindromes return False"""
        overhang = "AGTGA"
        assert is_valid_overhang(overhang) is False

    def test_repeated_nucleotides(self):
        """Test that overhangs with three consecutive repeated nucleotides return False"""
        overhang = "AAAGT"
        assert is_valid_overhang(overhang) is False

    def test_extreme_gc_content_0(self):
        """Test that overhangs with 0% GC content return False"""
        overhang = "AAA"
        assert is_valid_overhang(overhang) is False

    def test_extreme_gc_content_100(self):
        """Test that overhangs with 100% GC content return False"""
        overhang = "GGG"
        assert is_valid_overhang(overhang) is False

    def test_valid_overhang(self):
        """Test that valid overhangs return True"""
        overhang = "AGCTG"
        assert is_valid_overhang(overhang) is True

    def test_edge_case_empty_overhang(self):
        """Test that an empty overhang returns False"""
        overhang = ""
        assert is_valid_overhang(overhang) is True

    def test_edge_case_single_nucleotide(self):
        """Test that a single nucleotide overhang is valid"""
        overhang = "A"
        assert is_valid_overhang(overhang) is True

    def test_mixed_gc_content(self):
        """Test that overhangs with mixed GC content return True"""
        overhang = "AGTCG"
        assert is_valid_overhang(overhang) is True


class TestHammingDistance:
    """
       A test suite for the `hamming_distance` function, which calculates the number of positions
       at which two sequences of equal length differ.

       The tests cover various scenarios, including:
       - Identical sequences, where the Hamming distance should be 0.
       - Completely different sequences, where the Hamming distance should equal the length of the sequences.
       - Sequences that differ by only one position.
       - Empty sequences, where the Hamming distance should be 0.

       Methods:
           test_equal_sequences(): Tests that the Hamming distance is 0 for identical sequences.
           test_completely_different_sequences(): Tests that the Hamming distance equals the length of the sequences when completely different.
           test_one_difference(): Tests the Hamming distance for sequences that differ by one position.
           test_empty_sequences(): Tests the Hamming distance for empty sequences, expecting 0.
       """

    def test_equal_sequences(self):
        """Test if Hamming distance is 0 for identical sequences."""
        seq1 = "AGCTAG"
        seq2 = "AGCTAG"
        assert hamming_distance(seq1, seq2) == 0

    def test_completely_different_sequences(self):
        """Test if Hamming distance equals the length of the sequences when completely different."""
        seq1 = "AGCTAG"
        seq2 = "TCGATC"
        assert hamming_distance(seq1, seq2) == 6

    def test_one_difference(self):
        """Test Hamming distance for sequences that differ by one position."""
        seq1 = "AGCTAG"
        seq2 = "AGCTTG"
        assert hamming_distance(seq1, seq2) == 1

    def test_empty_sequences(self):
        """Test Hamming distance for empty sequences."""
        seq1 = ""
        seq2 = ""
        assert hamming_distance(seq1, seq2) == 0


class TestFindConstantIndices:
    """
        A test suite for the `find_constant_indices` function, which identifies the positions in a list of sequences
        that are constant (i.e., match the reference sequence at the same positions).

        The tests cover various scenarios, including:
        - Identical sequences, where all positions match the reference.
        - Sequences with partial matches to the reference at specific positions.
        - Sequences with no matches to the reference.
        - An empty list of sequences, where all positions are considered constant.
        - A list with only one sequence, checking how it compares to the reference.
        - Edge cases, including empty reference sequences and references that are one character long.

        Methods:
            test_identical_sequences(): Tests when all sequences are identical to the reference.
            test_partial_match(): Tests when sequences have some matching positions with the reference.
            test_no_match(): Tests when no positions match between the reference and the sequences.
            test_empty_sequences(): Tests when the sequences list is empty, expecting all positions to be constant.
            test_single_sequence(): Tests when there is only one sequence in the list, checking for constant positions.
            test_edge_case_empty_reference(): Tests when the reference sequence is empty, expecting no constant positions.
            test_edge_case_one_char_reference(): Tests when the reference sequence is one character long, checking for constant positions.
        """

    def test_identical_sequences(self):
        """Test when all sequences are identical to the reference."""
        reference = "AGCTAG"
        sequences = ["AGCTAG", "AGCTAG", "AGCTAG"]
        expected = [0, 1, 2, 3, 4, 5]
        assert find_constant_indices(reference, sequences) == expected

    def test_partial_match(self):
        """Test when sequences have some matching positions with the reference."""
        reference = "AGCTAG"
        sequences = ["AGCTGG", "TGCTAG", "AGCGAG"]
        expected = [1, 2, 5]
        assert find_constant_indices(reference, sequences) == expected

    def test_no_match(self):
        """Test when no positions match between the reference and the sequences."""
        reference = "AGCTAG"
        sequences = ["TTTAAA", "GGGGGG"]
        expected = []
        assert find_constant_indices(reference, sequences) == expected

    def test_empty_sequences(self):
        """Test when sequences list is empty."""
        reference = "AGCTAG"
        sequences = []
        expected = [0, 1, 2, 3, 4, 5]
        assert find_constant_indices(reference, sequences) == expected

    def test_single_sequence(self):
        """Test when there is only one sequence in the list."""
        reference = "AGCTAG"
        sequences = ["AGCTGG"]
        expected = [0, 1, 2, 3, 5]
        assert find_constant_indices(reference, sequences) == expected

    def test_edge_case_empty_reference(self):
        """Test when the reference sequence is empty."""
        reference = ""
        sequences = ["", ""]
        expected = []
        assert find_constant_indices(reference, sequences) == expected

    def test_edge_case_one_char_reference(self):
        """Test when the reference sequence is one character long."""
        reference = "A"
        sequences = ["A", "A", "A"]
        expected = [0]
        assert find_constant_indices(reference, sequences) == expected
